atomic도 좋은 방법이지만 일반적인 상황에서는 lock을 걸어가지고 활용하는 방법을 주로 사용한다. 

벡터에다가 push_back을 하려고 할때 여러 쓰레드에서 push_back을 한다면 기존에 있던 공간을 삭제하고 새로운 공간을 만들어야 하는데 그게 꼬여서 문제가 발생한다. 

벡터의 push_back을 하려고 할때 atomic을 사용하지 못하는 이유는 atomic을 사용한다고해서 vector의 기능을 사용하지 못하는데 push_back은 vector의 기능이기 때문이다. 

그래서 mutex를 사용해서 lock을 하고 lock, unlock을 통해 자물쇠를 잠그고 푸는 것처럼 사용할 수 있지만 재귀적으로 여러번은 사용하지 못한다. 함수안에 함수가 있고 물고무는 관계일때 재귀적으로 되지 않는다면 문제가 있다. 

lock을 수동적으로 매번 해줘야 하는것은 매우 복잡하고 실수가 나올 수 있는 부분이다. 그래서 RAII(Resource Acquisition Is Initialization)를 사용해서 자동적으로 lock이 되도록 해주는 것이 좋다.

RAII는 함수나 그런것이 아니라 방식의 이름인데 lockguard라는 템플릿을 만들어서 이게 자동적으로 lock이 되도록 해주는 것을 RAII라고 말할 수 있다. 

매번 lockguard라는 클래스를 만들 필요는 없고 std::lock_guard가 있다.

std::unique_lock라는 더 세부적인 lock도 있다. 