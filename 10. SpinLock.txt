mutex로 lock을 했던 예전 실습코드에서 SpinLock이라는 새로운 클래스를 만들어서 진짜 spinlock처럼 코드를 짜 구현해보았다. 

c++에서 volatile은 해당 변수의 컴파일러 최적화를 제한하는 용도로 사용한다. 예를 들어서 설명을 하자면
bool flag = true;
while(flag)
{
} 에서 디버깅을 해보면 그냥 while문 안으로 점프를 한다. 하지만 volatile을 붙이면 
volatile bool flag = true;
while(flag)
{
} 디버깅을 했을때 flag의 값을 체크하고 그 다음에 while문 안으로 점프를 하게 된다. 즉, 변동성이 실시간으로 생기는 것에서 어느 순간에 값이 변하는 것을 체크하려면 volatile이 필요하다.

사실 atomic을 사용하면 volatile 기능까지 사용한다.

spinlock의 단점으로는 쓸데없이 cpu를 낭비한다는점이다. 그래서 이 방법은 양날의 검이 될 수 있다. 

class SpinLock
{
public:
	void lock()
	{
		// CAS (Compare-And-Swap)

		bool expected = false;
		bool desired = true;

		while (_locked.compare_exchange_strong(expected, desired) == false)
		{
			expected = false;
		}
	}

	void unlock()
	{
		_locked.store(false);
	}

private:
	atomic<bool> _locked = false;
};

int32 sum = 0;
mutex m;
SpinLock spinLock;

void Add()
{
	for (int32 i = 0; i < 100000; i++)
	{
		lock_guard<SpinLock> guard(spinLock);
		sum++;
	}
}

void Sub()
{
	for (int32 i = 0; i < 100000; i++)
	{
		lock_guard<SpinLock> guard(spinLock);
		sum--;
	}
}

int main()
{	
	thread t1(Add);
	thread t2(Sub);

	t1.join();
	t2.join();

	cout << sum << endl;
}